package jwtToken

import (
	"crypto/rand"
	"errors"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"

	"yap-pwkeeper/internal/pkg/logger"
)

var (
	ErrNoSubject = errors.New("no subject for jwt")
	ErrSign      = errors.New("failed to sign jwt")
	ErrInvalid   = errors.New("invalid jwt")
	jwtKey       []byte
	jwtTTL       = 2 * time.Hour
	jwtSign      = jwt.SigningMethodHS256
)

func init() {
	jwtKey = make([]byte, 64)
	_, _ = rand.Read(jwtKey)
}

// SetKey sets key for token signing
func SetKey(key string) {
	if len(key) < 8 {
		logger.Log().Warn("token key is too short, using autogenerated")
		return
	}
	jwtKey = []byte(key)
}

// SetTTL sets JWT token lifetime
func SetTTL(ttl time.Duration) {
	jwtTTL = ttl
}

type JWTClaims struct {
	jwt.RegisteredClaims
	Session string `json:"session,omitempty"`
}

// genToken generates and signs tokens
func genToken(subject string, session string) (string, error) {
	var signed string
	if session == "" {
		session = uuid.NewString()
	}
	if subject == "" {
		return signed, ErrNoSubject
	}
	claims := &JWTClaims{
		RegisteredClaims: jwt.RegisteredClaims{
			Subject:   subject,
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(jwtTTL)),
			NotBefore: jwt.NewNumericDate(time.Now()),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			ID:        uuid.NewString(),
		},
		Session: session,
	}
	token := jwt.NewWithClaims(jwtSign, claims)
	signed, err := token.SignedString(jwtKey)
	if err != nil {
		return signed, fmt.Errorf("%w: %w", ErrSign, err)
	}
	return signed, nil
}

// NewToken is public function to request new token
func NewToken(subject string) (string, error) {
	return genToken(subject, "")
}

// RefreshToken issues new token to requests authorised by token
func RefreshToken(token string) (string, error) {
	if !Valid(token) {
		return "", ErrInvalid
	}
	return genToken(GetTokenSubject(token), GetTokenSession(token))
}

// Valid checks token (signature and method)
func Valid(signed string) bool {
	token, err := jwt.ParseWithClaims(signed, &JWTClaims{},
		func(token *jwt.Token) (interface{}, error) {
			return jwtKey, nil
		})
	if err != nil || !token.Valid || token.Method != jwtSign {
		return false
	}
	if GetTokenSession(signed) == "" || GetTokenSubject(signed) == "" {
		return false
	}
	return true
}

// getClaims extracts claims from token
func getClaims(token string) (*JWTClaims, error) {
	parsed, _, err := jwt.NewParser().ParseUnverified(token, &JWTClaims{})
	if err != nil {
		logger.Log().WithErr(err).Debug("token claims parse failed")
		return nil, err
	}
	return parsed.Claims.(*JWTClaims), err
}

// GetTokenSubject returns subject (userId) from token
func GetTokenSubject(token string) string {
	claims, err := getClaims(token)
	if err != nil {
		return ""
	}
	return claims.Subject
}

// GetTokenSession returns session claim from token. All tokens in chain of
// one successful Login have the save sessionId
func GetTokenSession(token string) string {
	claims, err := getClaims(token)
	if err != nil {
		return ""
	}
	return claims.Session
}

// GetTokenExpire returns token expiration time
func GetTokenExpire(token string) (time.Time, error) {
	claims, err := getClaims(token)
	if err != nil {
		return time.UnixMilli(0), err
	}
	return claims.ExpiresAt.Time, err
}
